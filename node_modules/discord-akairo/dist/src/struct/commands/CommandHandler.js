"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterInteractionCommandError = void 0;
const discord_js_1 = require("discord.js");
const AkairoError_js_1 = __importDefault(require("../../util/AkairoError.js"));
const AkairoMessage_js_1 = __importDefault(require("../../util/AkairoMessage.js"));
const Constants_js_1 = require("../../util/Constants.js");
const Util_js_1 = __importStar(require("../../util/Util.js"));
const AkairoHandler_js_1 = __importDefault(require("../AkairoHandler.js"));
const ContextMenuCommandHandler_js_1 = __importDefault(require("../contextMenuCommands/ContextMenuCommandHandler.js"));
const TypeResolver_js_1 = __importDefault(require("./arguments/TypeResolver.js"));
const Command_1 = __importDefault(require("./Command"));
const CommandUtil_js_1 = __importDefault(require("./CommandUtil.js"));
const Flag_js_1 = __importStar(require("./Flag.js"));
/**
 * Loads commands and handles messages.
 */
class CommandHandler extends AkairoHandler_js_1.default {
    /**
     * @param client - The Akairo client.
     * @param options - Options.
     */
    // eslint-disable-next-line complexity
    constructor(client, options) {
        const { directory, classToHandle = Command_1.default, extensions = [".js", ".ts"], automateCategories, loadFilter, blockClient = true, blockBots = true, fetchMembers = false, handleEdits = false, storeMessages = false, commandUtil = false, commandUtilLifetime = 3e5, commandUtilSweepInterval = 3e5, defaultCooldown = 0, ignoreCooldown = client.ownerID, ignorePermissions = [], argumentDefaults = {}, prefix = "!", allowMention = true, aliasReplacement, autoDefer = false, typing = false, autoRegisterSlashCommands = false, execSlash = false, skipBuiltInPostInhibitors = false, useSlashPermissions = false } = options ?? {};
        if (!(classToHandle.prototype instanceof Command_1.default || classToHandle === Command_1.default)) {
            throw new AkairoError_js_1.default("INVALID_CLASS_TO_HANDLE", classToHandle.name, Command_1.default.name);
        }
        if (typeof blockClient !== "boolean")
            throw new TypeError("options.blockClient must be a boolean.");
        if (typeof blockBots !== "boolean")
            throw new TypeError("options.blockBots must be a boolean.");
        if (typeof fetchMembers !== "boolean")
            throw new TypeError("options.fetchMembers must be a boolean.");
        if (typeof handleEdits !== "boolean")
            throw new TypeError("options.handleEdits must be a boolean.");
        if (typeof storeMessages !== "boolean")
            throw new TypeError("options.storeMessages must be a boolean.");
        if (typeof commandUtil !== "boolean")
            throw new TypeError("options.commandUtil must be a boolean.");
        if (typeof commandUtilLifetime !== "number")
            throw new TypeError("options.commandUtilLifetime must be a number.");
        if (typeof commandUtilSweepInterval !== "number")
            throw new TypeError("options.commandUtilSweepInterval must be a number.");
        if (typeof defaultCooldown !== "number")
            throw new TypeError("options.defaultCooldown must be a number.");
        if (!(0, Util_js_1.isStringArrayStringOrFunc)(ignoreCooldown))
            throw new TypeError("options.ignoreCooldown must be a string, an array of strings, or a function.");
        if (!(0, Util_js_1.isStringArrayStringOrFunc)(ignorePermissions))
            throw new TypeError("options.ignorePermissions must be a string, an array of strings, or a function.");
        if (typeof argumentDefaults !== "object")
            throw new TypeError("options.argumentDefaults must be an object.");
        if (!(0, Util_js_1.isStringArrayStringOrFunc)(prefix))
            throw new TypeError("options.prefix must be a string, an array of strings, or a function.");
        if (typeof allowMention !== "boolean" && typeof allowMention !== "function")
            throw new TypeError("options.allowMention must be a boolean.");
        if (aliasReplacement !== undefined && !(aliasReplacement instanceof RegExp))
            throw new TypeError("options.aliasReplacement must be a RegExp.");
        if (typeof autoDefer !== "boolean")
            throw new TypeError("options.autoDefer must be a boolean.");
        if (typeof typing !== "boolean")
            throw new TypeError("options.typing must be a boolean.");
        if (typeof autoRegisterSlashCommands !== "boolean")
            throw new TypeError("options.autoRegisterSlashCommands must be a boolean.");
        if (typeof execSlash !== "boolean")
            throw new TypeError("options.execSlash must be a boolean.");
        if (typeof skipBuiltInPostInhibitors !== "boolean")
            throw new TypeError("options.skipBuiltInPostInhibitors must be a boolean.");
        if (typeof useSlashPermissions !== "boolean")
            throw new TypeError("options.useSlashPermissions must be a boolean.");
        super(client, {
            directory,
            classToHandle,
            extensions,
            automateCategories,
            loadFilter
        });
        this.autoRegisterSlashCommands = autoRegisterSlashCommands;
        this.typing = typing;
        this.autoDefer = autoDefer;
        this.resolver = new TypeResolver_js_1.default(this);
        this.aliases = new discord_js_1.Collection();
        this.aliasReplacement = aliasReplacement;
        this.prefixes = new discord_js_1.Collection();
        this.blockClient = blockClient;
        this.blockBots = blockBots;
        this.fetchMembers = fetchMembers;
        this.handleEdits = handleEdits;
        this.storeMessages = storeMessages;
        this.commandUtil = commandUtil;
        if ((this.handleEdits || this.storeMessages) && !this.commandUtil)
            throw new AkairoError_js_1.default("COMMAND_UTIL_EXPLICIT");
        this.commandUtilLifetime = commandUtilLifetime;
        this.commandUtilSweepInterval = commandUtilSweepInterval;
        if (this.commandUtilSweepInterval > 0)
            setInterval(() => this.sweepCommandUtil(), this.commandUtilSweepInterval).unref();
        this.commandUtils = new discord_js_1.Collection();
        this.cooldowns = new discord_js_1.Collection();
        this.defaultCooldown = defaultCooldown;
        this.ignoreCooldown = typeof ignoreCooldown === "function" ? ignoreCooldown.bind(this) : ignoreCooldown;
        this.ignorePermissions = typeof ignorePermissions === "function" ? ignorePermissions.bind(this) : ignorePermissions;
        this.prompts = new discord_js_1.Collection();
        this.argumentDefaults = Util_js_1.default.deepAssign({
            prompt: {
                start: "",
                retry: "",
                timeout: "",
                ended: "",
                cancel: "",
                retries: 1,
                time: 30000,
                cancelWord: "cancel",
                stopWord: "stop",
                optional: false,
                infinite: false,
                limit: Infinity,
                breakout: true
            }
        }, argumentDefaults);
        this.prefix = typeof prefix === "function" ? prefix.bind(this) : prefix;
        this.allowMention = typeof allowMention === "function" ? allowMention.bind(this) : Boolean(allowMention);
        this.inhibitorHandler = null;
        this.autoDefer = Boolean(autoDefer);
        this.execSlash = Boolean(execSlash);
        this.skipBuiltInPostInhibitors = Boolean(skipBuiltInPostInhibitors);
        this.useSlashPermissions = Boolean(useSlashPermissions);
        this.setup();
    }
    /**
     * Set up the command handler
     */
    setup() {
        this.client.once("ready", () => {
            if (this.autoRegisterSlashCommands)
                this.registerInteractionCommands().then(() => {
                    if (this.useSlashPermissions)
                        this.updateInteractionPermissions(this.client.ownerID /*  this.client.superUserID */);
                });
            this.client.on("messageCreate", async (m) => {
                const message = m.partial ? await m.fetch().catch(() => null) : m;
                if (!message)
                    return;
                this.handle(m);
            });
            if (this.handleEdits) {
                this.client.on("messageUpdate", async (o, m) => {
                    const message = m.partial ? await m.fetch().catch(() => null) : m;
                    if (!message)
                        return;
                    const original = o.partial ? await o.fetch().catch(() => null) : o;
                    if (!original)
                        return;
                    if (original.content === message.content)
                        return;
                    if (this.handleEdits)
                        this.handle(message);
                });
            }
            this.client.on("interactionCreate", i => {
                if (i.isChatInputCommand())
                    this.handleSlash(i);
                if (i.isAutocomplete())
                    this.handleAutocomplete(i);
            });
        });
        if (this.commandUtil)
            this.client.on("messageDelete", message => {
                if (message.inGuild()) {
                    CommandUtil_js_1.default.deletedMessages.add(message.id);
                }
            });
    }
    /**
     * Registers interaction commands.
     */
    async registerInteractionCommands() {
        this.client.emit("akairoDebug", `[registerInteractionCommands] Started registering interaction commands...`);
        const parsedSlashCommands = [];
        const guildSlashCommandsParsed = new discord_js_1.Collection();
        const parseDescriptionCommand = (description) => {
            if (typeof description === "object") {
                if (typeof description.content === "function")
                    return description.content();
                if (typeof description.content === "string")
                    return description.content;
            }
            return description;
        };
        for (const [, data] of this.modules) {
            if (!data.slash)
                continue;
            parsedSlashCommands.push({
                name: data.aliases[0]?.toLowerCase() || data.id?.toLowerCase(),
                description: parseDescriptionCommand(data.description) || "No description provided.",
                options: data.slashOptions?.map(o => {
                    const temp = { ...o };
                    delete temp.resolve;
                    return temp;
                }),
                guilds: data.slashGuilds ?? [],
                defaultPermission: data.slashDefaultPermission,
                type: 1 /* ChatInput */
            });
        }
        let contextCommandHandler;
        for (const key in this.client) {
            if (this.client[key] instanceof ContextMenuCommandHandler_js_1.default) {
                contextCommandHandler = this.client[key];
                break;
            }
        }
        if (contextCommandHandler) {
            for (const [, data] of contextCommandHandler.modules) {
                parsedSlashCommands.push({
                    name: data.name,
                    guilds: data.guilds ?? [],
                    defaultPermission: this.useSlashPermissions ? !(data.ownerOnly || /* data.superUserOnly || */ false) : true,
                    type: data.type
                });
            }
        }
        /* Global */
        const slashCommandsApp = parsedSlashCommands
            .filter(({ guilds }) => !guilds.length)
            .map(options => ({
            name: options.name,
            description: options.type === 1 /* ChatInput */ ? options.description ?? "" : undefined,
            options: options.type === 1 /* ChatInput */ ? options.options ?? [] : undefined,
            defaultPermission: options.defaultPermission,
            type: options.type
        }))
            .sort((a, b) => {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        });
        const currentGlobalCommands = (await this.client.application?.commands.fetch())
            .map(value1 => ({
            name: value1.name,
            description: value1.description,
            options: value1.options,
            defaultPermission: value1.defaultPermission,
            type: value1.type
        }))
            .sort((a, b) => {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        });
        if (!Util_js_1.default.deepEquals(currentGlobalCommands, slashCommandsApp)) {
            this.client.emit("akairoDebug", "[registerInteractionCommands] Updating global interaction commands.", slashCommandsApp);
            await this.client.application?.commands.set(slashCommandsApp).catch(error => {
                if (error instanceof discord_js_1.DiscordAPIError)
                    throw new RegisterInteractionCommandError(error, "global", slashCommandsApp);
                else
                    throw error;
            });
        }
        else {
            this.client.emit("akairoDebug", "[registerInteractionCommands] Global interaction commands are up to date.");
        }
        /* Guilds */
        for (const options of parsedSlashCommands) {
            for (const guildId of options.guilds) {
                guildSlashCommandsParsed.set(guildId, [
                    ...(guildSlashCommandsParsed.get(guildId) ?? []),
                    {
                        name: options.name,
                        description: options.type === 1 /* ChatInput */ ? options.description ?? "" : undefined,
                        options: options.type === 1 /* ChatInput */ ? options.options ?? [] : undefined,
                        defaultPermission: options.defaultPermission,
                        type: options.type
                    }
                ]);
            }
        }
        if (guildSlashCommandsParsed.size) {
            guildSlashCommandsParsed.each(async (value, key) => {
                const guild = this.client.guilds.cache.get(key);
                if (!guild)
                    return;
                const sortedCommands = value.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
                const currentGuildCommands = (await guild.commands.fetch())
                    .map(value1 => ({
                    name: value1.name,
                    description: value1.description,
                    options: value1.options,
                    defaultPermission: value1.defaultPermission,
                    type: value1.type
                }))
                    .sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
                if (!Util_js_1.default.deepEquals(currentGuildCommands, sortedCommands)) {
                    this.client.emit("akairoDebug", `[registerInteractionCommands] Updating guild commands for ${guild.name}.`, sortedCommands);
                    await guild.commands.set(sortedCommands).catch(error => {
                        if (error instanceof discord_js_1.DiscordAPIError)
                            throw new RegisterInteractionCommandError(error, "guild", sortedCommands, guild);
                        else
                            throw error;
                    });
                }
                else {
                    this.client.emit("akairoDebug", `[registerInteractionCommands] No changes needed for ${guild.name}.`);
                }
            });
        }
    }
    /**
     * updates interaction permissions
     */
    async updateInteractionPermissions(owners /* superUsers: Snowflake | Snowflake[] */) {
        const mapCom = (value, guild) => {
            const command = this.modules.find(mod => mod.aliases[0] === value.name);
            if (!command?.slashPermissions) {
                let allowedUsers = [];
                /* if (command.superUserOnly) allowedUsers.push(...Util.intoArray(superUsers)); */
                if (command?.ownerOnly)
                    allowedUsers.push(...Util_js_1.default.intoArray(owners));
                allowedUsers = [...new Set(allowedUsers)]; // remove duplicates
                return {
                    id: value.id,
                    permissions: allowedUsers.map(u => ({
                        id: u,
                        type: 2 /* User */,
                        permission: true
                    }))
                };
            }
            else {
                return {
                    id: value.id,
                    permissions: typeof command.slashPermissions === "function" ? command.slashPermissions(guild) : command.slashPermissions
                };
            }
        };
        const globalCommands = (await this.client.application?.commands.fetch())?.filter(value => Boolean(this.modules.find(mod => mod.aliases[0] === value.name)));
        const fullPermissions = globalCommands
            ?.filter(value => !value.defaultPermission)
            .filter(value => Boolean(this.modules.find(mod => mod.aliases[0] === value.name)));
        const promises = this.client.guilds.cache.map(
        /* async */ guild => {
            const perms = new Array(...((fullPermissions ?? new discord_js_1.Collection()).map(value => mapCom(value, guild)) ?? []));
            // await guild.commands.fetch();
            if (guild.commands.cache.size)
                perms.push(...guild.commands.cache.filter(value => !value.defaultPermission).map(value => mapCom(value, guild)));
            if (guild.available)
                return guild.commands.permissions.set({
                    fullPermissions: perms
                });
            // Return empty promise if guild is unavailable
            return Promise.resolve();
        });
        try {
            await Promise.all(promises);
        }
        catch (e) {
            this.client.emit("akairoDebug", "[updateInteractionPermissions] Error updating interaction permissions, here are the promises, globalCommands, and fullPermissions", promises, globalCommands, fullPermissions);
            throw e;
        }
    }
    /**
     * Registers a module.
     * @param command - Module to use.
     * @param filepath - Filepath of module.
     */
    register(command, filepath) {
        super.register(command, filepath);
        if (command.slashDefaultPermission === undefined)
            command.slashDefaultPermission = this.useSlashPermissions ? !command.ownerOnly : true;
        for (let alias of command.aliases) {
            const conflict = this.aliases.get(alias.toLowerCase());
            if (conflict)
                throw new AkairoError_js_1.default("ALIAS_CONFLICT", alias, command.id, conflict);
            alias = alias.toLowerCase();
            this.aliases.set(alias, command.id);
            if (this.aliasReplacement) {
                const replacement = alias.replace(this.aliasReplacement, "");
                if (replacement !== alias) {
                    const replacementConflict = this.aliases.get(replacement);
                    if (replacementConflict)
                        throw new AkairoError_js_1.default("ALIAS_CONFLICT", replacement, command.id, replacementConflict);
                    this.aliases.set(replacement, command.id);
                }
            }
        }
        if (command.prefix != null) {
            let newEntry = false;
            if (Array.isArray(command.prefix)) {
                for (const prefix of command.prefix) {
                    const prefixes = this.prefixes.get(prefix);
                    if (prefixes) {
                        prefixes.add(command.id);
                    }
                    else {
                        this.prefixes.set(prefix, new Set([command.id]));
                        newEntry = true;
                    }
                }
            }
            else {
                const prefixes = this.prefixes.get(command.prefix);
                if (prefixes) {
                    prefixes.add(command.id);
                }
                else {
                    this.prefixes.set(command.prefix, new Set([command.id]));
                    newEntry = true;
                }
            }
            if (newEntry) {
                this.prefixes = this.prefixes.sort((aVal, bVal, aKey, bKey) => Util_js_1.default.prefixCompare(aKey, bKey));
            }
        }
    }
    /**
     * Deregisters a module.
     * @param command - Module to use.
     */
    deregister(command) {
        for (let alias of command.aliases) {
            alias = alias.toLowerCase();
            this.aliases.delete(alias);
            if (this.aliasReplacement) {
                const replacement = alias.replace(this.aliasReplacement, "");
                if (replacement !== alias)
                    this.aliases.delete(replacement);
            }
        }
        if (command.prefix != null) {
            if (Array.isArray(command.prefix)) {
                for (const prefix of command.prefix) {
                    const prefixes = this.prefixes.get(prefix);
                    if (prefixes?.size === 1) {
                        this.prefixes.delete(prefix);
                    }
                    else {
                        prefixes?.delete(prefix);
                    }
                }
            }
            else {
                const prefixes = this.prefixes.get(command.prefix);
                if (prefixes?.size === 1) {
                    this.prefixes.delete(command.prefix);
                }
                else {
                    prefixes?.delete(command.prefix);
                }
            }
        }
        super.deregister(command);
    }
    /**
     * Handles a message.
     * @param message - Message to handle.
     */
    async handle(message) {
        try {
            if (this.fetchMembers && message.guild && !message.member && !message.webhookId) {
                await message.guild.members.fetch(message.author);
            }
            if (await this.runAllTypeInhibitors(message)) {
                return false;
            }
            if (this.commandUtil) {
                if (this.commandUtils.has(message.id)) {
                    message.util = this.commandUtils.get(message.id);
                }
                else {
                    message.util = new CommandUtil_js_1.default(this, message);
                    this.commandUtils.set(message.id, message.util);
                }
            }
            if (await this.runPreTypeInhibitors(message)) {
                return false;
            }
            let parsed = await this.parseCommand(message);
            if (!parsed.command) {
                const overParsed = await this.parseCommandOverwrittenPrefixes(message);
                if (overParsed.command || (parsed.prefix == null && overParsed.prefix != null)) {
                    parsed = overParsed;
                }
            }
            if (this.commandUtil) {
                message.util.parsed = parsed;
            }
            if (parsed.command?.slashOnly) {
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_ONLY, message, parsed.command);
                return false;
            }
            let ran;
            if (!parsed.command) {
                ran = await this.handleRegexAndConditionalCommands(message);
            }
            else {
                ran = await this.handleDirectCommand(message, parsed.content, parsed.command);
            }
            if (ran === false) {
                this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_INVALID, message);
                return false;
            }
            return ran;
        }
        catch (err) {
            this.emitError(err, message);
            return null;
        }
    }
    /**
     * Handles a slash command.
     * @param interaction - Interaction to handle.
     */
    // eslint-disable-next-line complexity
    async handleSlash(interaction) {
        const commandModule = this.findCommand(interaction.commandName);
        if (!commandModule) {
            this.emit(Constants_js_1.CommandHandlerEvents.SLASH_NOT_FOUND, interaction);
            return false;
        }
        const message = new AkairoMessage_js_1.default(this.client, interaction);
        try {
            if (this.fetchMembers && message.guild && !message.member) {
                await message.guild.members.fetch(message.author);
            }
            if (await this.runAllTypeInhibitors(message, true)) {
                return false;
            }
            if (this.commandUtil) {
                if (this.commandUtils.has(message.id)) {
                    message.util = this.commandUtils.get(message.id);
                }
                else {
                    message.util = new CommandUtil_js_1.default(this, message);
                    this.commandUtils.set(message.id, message.util);
                }
            }
            if (await this.runPreTypeInhibitors(message)) {
                return false;
            }
            let parsed = await this.parseCommand(message);
            if (!parsed.command) {
                const overParsed = await this.parseCommandOverwrittenPrefixes(message);
                if (overParsed.command || (parsed.prefix == null && overParsed.prefix != null)) {
                    parsed = overParsed;
                }
            }
            if (this.commandUtil) {
                message.util.parsed = parsed;
            }
            if (await this.runPostTypeInhibitors(message, commandModule)) {
                return false;
            }
            const convertedOptions = {};
            if (interaction.options["_group"])
                convertedOptions["subcommandGroup"] = interaction.options["_group"];
            if (interaction.options["_subcommand"])
                convertedOptions["subcommand"] = interaction.options["_subcommand"];
            for (const option of interaction.options["_hoistedOptions"]) {
                if (option.type === 1 /* Subcommand */ ||
                    option.type === 2 /* SubcommandGroup */)
                    continue;
                const originalOption = commandModule.slashOptions?.find(o => o.name === option.name);
                const func = `get${originalOption?.resolve ?? AkairoApplicationCommandOptionType[option.type]}`;
                if (![
                    "getBoolean",
                    "getChannel",
                    "getString",
                    "getInteger",
                    "getNumber",
                    "getUser",
                    "getMember",
                    "getRole",
                    "getMentionable"
                ].includes(func))
                    throw new Error(` ${option.type}`);
                convertedOptions[option.name] = interaction.options[func](option.name, false);
            }
            // Makes options that are not found to be null so that it matches the behavior normal commands.
            (() => {
                if (convertedOptions.subcommand || convertedOptions.subcommandGroup) {
                    const usedSubcommandOrGroup = commandModule.slashOptions?.find(o => o.name === convertedOptions.subcommand);
                    if (!usedSubcommandOrGroup) {
                        this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand");
                        return;
                    }
                    if (usedSubcommandOrGroup.type === 1 /* Subcommand */) {
                        if (!usedSubcommandOrGroup.options) {
                            this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand options");
                            return;
                        }
                        handleOptions(usedSubcommandOrGroup.options);
                    }
                    else if (usedSubcommandOrGroup.type === 2 /* SubcommandGroup */) {
                        const usedSubCommand = usedSubcommandOrGroup.options?.find(subcommand => subcommand.name === convertedOptions.subcommand);
                        if (!usedSubCommand) {
                            this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand");
                            return;
                        }
                        else if (!usedSubCommand.options) {
                            this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand options");
                            return;
                        }
                        handleOptions(usedSubCommand.options);
                    }
                    else {
                        throw new AkairoError_js_1.default("UNEXPECTED_SLASH_COMMAND_TYPE", usedSubcommandOrGroup.type);
                    }
                }
                else {
                    handleOptions((commandModule.slashOptions ?? []));
                }
                function handleOptions(options) {
                    for (const option of options) {
                        switch (option.type) {
                            case 5 /* Boolean */:
                                convertedOptions[option.name] ??= false;
                                break;
                            case 7 /* Channel */:
                            case 4 /* Integer */:
                            case 9 /* Mentionable */:
                            case 10 /* Number */:
                            case 8 /* Role */:
                            case 3 /* String */:
                            case 6 /* User */:
                            default:
                                convertedOptions[option.name] ??= null;
                                break;
                        }
                    }
                }
            })();
            let key;
            try {
                if (commandModule.lock)
                    key = commandModule.lock(message, convertedOptions);
                if (Util_js_1.default.isPromise(key))
                    key = await key;
                if (key) {
                    if (commandModule.locker?.has(key)) {
                        key = null;
                        this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_LOCKED, message, commandModule);
                        return true;
                    }
                    commandModule.locker?.add(key);
                }
            }
            catch (err) {
                this.emitError(err, message, commandModule);
            }
            finally {
                if (key)
                    commandModule.locker?.delete(key);
            }
            if (this.autoDefer || commandModule.slashEphemeral) {
                await interaction.deferReply({ ephemeral: commandModule.slashEphemeral });
            }
            try {
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_STARTED, message, commandModule, convertedOptions);
                const ret = Object.getOwnPropertyNames(Object.getPrototypeOf(commandModule)).includes("execSlash") || this.execSlash
                    ? await commandModule.execSlash(message, convertedOptions)
                    : await commandModule.exec(message, convertedOptions);
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_FINISHED, message, commandModule, convertedOptions, ret);
                return true;
            }
            catch (err) {
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_ERROR, err, message, commandModule);
                return false;
            }
        }
        catch (err) {
            this.emitError(err, message, commandModule);
            return null;
        }
    }
    /**
     * Handles autocomplete interactions.
     * @param interaction The interaction to handle.
     */
    handleAutocomplete(interaction) {
        const commandModule = this.findCommand(interaction.commandName);
        if (!commandModule) {
            this.emit(Constants_js_1.CommandHandlerEvents.SLASH_NOT_FOUND, interaction);
            return;
        }
        this.client.emit("akairoDebug", `[handleAutocomplete] Autocomplete started for ${interaction.commandName}`);
        commandModule.autocomplete(interaction);
    }
    /**
     * Handles normal commands.
     * @param message - Message to handle.
     * @param content - Content of message without command.
     * @param command - Command instance.
     * @param ignore - Ignore inhibitors and other checks.
     */
    async handleDirectCommand(message, content, command, ignore = false) {
        let key;
        try {
            if (!ignore) {
                if (message.editedTimestamp && !command.editable)
                    return false;
                if (await this.runPostTypeInhibitors(message, command))
                    return false;
            }
            const before = command.before(message);
            if (Util_js_1.default.isPromise(before))
                await before;
            const args = await command.parse(message, content);
            if (Flag_js_1.default.is(args, Flag_js_1.FlagType.Cancel)) {
                this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_CANCELLED, message, command);
                return true;
            }
            else if (Flag_js_1.default.is(args, Flag_js_1.FlagType.Retry)) {
                this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_BREAKOUT, message, command, args.message);
                return this.handle(args.message);
            }
            else if (Flag_js_1.default.is(args, Flag_js_1.FlagType.Continue)) {
                const continueCommand = this.modules.get(args.command);
                return this.handleDirectCommand(message, args.rest, continueCommand, args.ignore);
            }
            if (!ignore) {
                if (command.lock)
                    key = command.lock(message, args);
                if (Util_js_1.default.isPromise(key))
                    key = await key;
                if (key) {
                    if (command.locker?.has(key)) {
                        key = null;
                        this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_LOCKED, message, command);
                        return true;
                    }
                    command.locker?.add(key);
                }
            }
            await this.runCommand(message, command, args);
            return true;
        }
        catch (err) {
            this.emitError(err, message, command);
            return null;
        }
        finally {
            if (key)
                command.locker?.delete(key);
        }
    }
    /**
     * Handles regex and conditional commands.
     * @param message - Message to handle.
     */
    async handleRegexAndConditionalCommands(message) {
        const ran1 = await this.handleRegexCommands(message);
        const ran2 = await this.handleConditionalCommands(message);
        return ran1 || ran2;
    }
    /**
     * Handles regex commands.
     * @param message - Message to handle.
     */
    async handleRegexCommands(message) {
        const hasRegexCommands = [];
        for (const command of this.modules.values()) {
            if (message.editedTimestamp ? command.editable : true) {
                const regex = typeof command.regex === "function" ? command.regex(message) : command.regex;
                if (regex)
                    hasRegexCommands.push({ command, regex });
            }
        }
        const matchedCommands = [];
        for (const entry of hasRegexCommands) {
            const match = message.content.match(entry.regex);
            if (!match)
                continue;
            const matches = [];
            if (entry.regex.global) {
                let matched;
                while ((matched = entry.regex.exec(message.content)) != null) {
                    matches.push(matched);
                }
            }
            matchedCommands.push({ command: entry.command, match, matches });
        }
        if (!matchedCommands.length) {
            return false;
        }
        const promises = [];
        for (const { command, match, matches } of matchedCommands) {
            promises.push((async () => {
                try {
                    if (await this.runPostTypeInhibitors(message, command))
                        return;
                    const before = command.before(message);
                    if (Util_js_1.default.isPromise(before))
                        await before;
                    await this.runCommand(message, command, { match, matches });
                }
                catch (err) {
                    this.emitError(err, message, command);
                }
            })());
        }
        await Promise.all(promises);
        return true;
    }
    /**
     * Handles conditional commands.
     * @param message - Message to handle.
     */
    async handleConditionalCommands(message) {
        const trueCommands = [];
        const filterPromises = [];
        for (const command of this.modules.values()) {
            if (message.editedTimestamp && !command.editable)
                continue;
            filterPromises.push((async () => {
                let cond = command.condition(message);
                if (Util_js_1.default.isPromise(cond))
                    cond = await cond;
                if (cond)
                    trueCommands.push(command);
            })());
        }
        await Promise.all(filterPromises);
        if (!trueCommands.length) {
            return false;
        }
        const promises = [];
        for (const command of trueCommands) {
            promises.push((async () => {
                try {
                    if (await this.runPostTypeInhibitors(message, command))
                        return;
                    const before = command.before(message);
                    if (Util_js_1.default.isPromise(before))
                        await before;
                    await this.runCommand(message, command, {});
                }
                catch (err) {
                    this.emitError(err, message, command);
                }
            })());
        }
        await Promise.all(promises);
        return true;
    }
    /**
     * Runs inhibitors with the all type.
     * @param message - Message to handle.
     * @param slash - Whether or not the command should is a slash command.
     */
    async runAllTypeInhibitors(message, slash = false) {
        const reason = this.inhibitorHandler ? await this.inhibitorHandler.test("all", message) : null;
        if (reason != null) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, reason);
        }
        else if (!message.author) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, Constants_js_1.BuiltInReasons.AUTHOR_NOT_FOUND);
        }
        else if (this.blockClient && message.author.id === this.client.user?.id) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, Constants_js_1.BuiltInReasons.CLIENT);
        }
        else if (this.blockBots && message.author.bot) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, Constants_js_1.BuiltInReasons.BOT);
        }
        else if (!slash && this.hasPrompt(message.channel, message.author)) {
            this.emit(Constants_js_1.CommandHandlerEvents.IN_PROMPT, message);
        }
        else {
            return false;
        }
        return true;
    }
    /**
     * Runs inhibitors with the pre type.
     * @param message - Message to handle.
     */
    async runPreTypeInhibitors(message) {
        const reason = this.inhibitorHandler ? await this.inhibitorHandler.test("pre", message) : null;
        if (reason != null) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, reason);
        }
        else {
            return false;
        }
        return true;
    }
    /**
     * Runs inhibitors with the post type.
     * @param message - Message to handle.
     * @param command - Command to handle.
     * @param slash - Whether or not the command should is a slash command.
     */
    async runPostTypeInhibitors(message, command, slash = false) {
        const event = slash ? Constants_js_1.CommandHandlerEvents.SLASH_BLOCKED : Constants_js_1.CommandHandlerEvents.COMMAND_BLOCKED;
        if (!this.skipBuiltInPostInhibitors) {
            if (command.ownerOnly) {
                const isOwner = this.client.isOwner(message.author);
                if (!isOwner) {
                    this.emit(event, message, command, Constants_js_1.BuiltInReasons.OWNER);
                    return true;
                }
            }
            if (command.superUserOnly) {
                const isSuperUser = this.client.isSuperUser(message.author);
                if (!isSuperUser) {
                    this.emit(event, message, command, Constants_js_1.BuiltInReasons.SUPER_USER);
                    return true;
                }
            }
            if (command.channel === "guild" && !message.inGuild()) {
                this.emit(event, message, command, Constants_js_1.BuiltInReasons.GUILD);
                return true;
            }
            if (command.channel === "dm" && message.inGuild()) {
                this.emit(event, message, command, Constants_js_1.BuiltInReasons.DM);
                return true;
            }
            if (command.onlyNsfw && !("nsfw" in (message.channel ?? {}))) {
                this.emit(event, message, command, Constants_js_1.BuiltInReasons.NOT_NSFW);
                return true;
            }
        }
        if (!this.skipBuiltInPostInhibitors) {
            if (await this.runPermissionChecks(message, command, slash)) {
                return true;
            }
        }
        const reason = this.inhibitorHandler ? await this.inhibitorHandler.test("post", message, command) : null;
        if (this.skipBuiltInPostInhibitors && reason == null) {
            if (await this.runPermissionChecks(message, command, slash)) {
                return true;
            }
        }
        if (reason != null) {
            this.emit(event, message, command, reason);
            return true;
        }
        if (this.runCooldowns(message, command)) {
            return true;
        }
        return false;
    }
    /**
     * Runs permission checks.
     * @param message - Message that called the command.
     * @param command - Command to cooldown.
     * @param slash - Whether or not the command is a slash command.
     */
    async runPermissionChecks(message, command, slash = false) {
        const event = slash ? Constants_js_1.CommandHandlerEvents.SLASH_MISSING_PERMISSIONS : Constants_js_1.CommandHandlerEvents.MISSING_PERMISSIONS;
        if (command.clientPermissions) {
            if (typeof command.clientPermissions === "function") {
                let missing = command.clientPermissions(message);
                if (Util_js_1.default.isPromise(missing))
                    missing = await missing;
                if (missing != null) {
                    this.emit(event, message, command, "client", missing);
                    return true;
                }
            }
            else if (message.guild) {
                if (message.channel?.type === 1 /* DM */)
                    return false;
                const missing = message.channel?.permissionsFor(message.guild.me)?.missing(command.clientPermissions);
                if (missing?.length) {
                    this.emit(event, message, command, "client", missing);
                    return true;
                }
            }
        }
        if (command.userPermissions) {
            const ignorer = command.ignorePermissions || this.ignorePermissions;
            const isIgnored = Array.isArray(ignorer)
                ? ignorer.includes(message.author.id)
                : typeof ignorer === "function"
                    ? ignorer(message, command)
                    : message.author.id === ignorer;
            if (!isIgnored) {
                if (typeof command.userPermissions === "function") {
                    let missing = command.userPermissions(message);
                    if (Util_js_1.default.isPromise(missing))
                        missing = await missing;
                    if (missing != null) {
                        this.emit(event, message, command, "user", missing);
                        return true;
                    }
                }
                else if (message.guild) {
                    if (message.channel?.type === 1 /* DM */)
                        return false;
                    const missing = message.channel?.permissionsFor(message.author)?.missing(command.userPermissions);
                    if (missing?.length) {
                        this.emit(event, message, command, "user", missing);
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Runs cooldowns and checks if a user is under cooldown.
     * @param message - Message that called the command.
     * @param command - Command to cooldown.
     */
    runCooldowns(message, command) {
        const id = message.author?.id;
        const ignorer = command.ignoreCooldown || this.ignoreCooldown;
        const isIgnored = Array.isArray(ignorer)
            ? ignorer.includes(id)
            : typeof ignorer === "function"
                ? ignorer(message, command)
                : id === ignorer;
        if (isIgnored)
            return false;
        const time = command.cooldown != null ? command.cooldown : this.defaultCooldown;
        if (!time)
            return false;
        const endTime = message.createdTimestamp + time;
        if (!this.cooldowns.has(id))
            this.cooldowns.set(id, {});
        if (!this.cooldowns.get(id)[command.id]) {
            this.cooldowns.get(id)[command.id] = {
                timer: setTimeout(() => {
                    if (this.cooldowns.get(id)[command.id]) {
                        clearTimeout(this.cooldowns.get(id)[command.id].timer);
                    }
                    this.cooldowns.get(id)[command.id] = null;
                    if (!Object.keys(this.cooldowns.get(id)).length) {
                        this.cooldowns.delete(id);
                    }
                }, time).unref(),
                end: endTime,
                uses: 0
            };
        }
        const entry = this.cooldowns.get(id)[command.id];
        if (entry.uses >= command.ratelimit) {
            const end = this.cooldowns.get(id)[command.id].end;
            const diff = end - message.createdTimestamp;
            this.emit(Constants_js_1.CommandHandlerEvents.COOLDOWN, message, command, diff);
            return true;
        }
        entry.uses++;
        return false;
    }
    /**
     * Runs a command.
     * @param message - Message to handle.
     * @param command - Command to handle.
     * @param args - Arguments to use.
     */
    async runCommand(message, command, args) {
        if (!command || !message) {
            this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_INVALID, message, command);
            return;
        }
        const typing = command.typing || this.typing
            ? setInterval(() => {
                if (command.typing || this.typing)
                    message.channel.sendTyping();
            }, 9000)
            : undefined;
        try {
            this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_STARTED, message, command, args);
            const ret = await command.exec(message, args);
            this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_FINISHED, message, command, args, ret);
        }
        finally {
            if (typing)
                clearInterval(typing);
        }
    }
    /**
     * Parses the command and its argument list.
     * @param message - Message that called the command.
     */
    async parseCommand(message) {
        const allowMention = await Util_js_1.default.intoCallable(this.prefix)(message);
        let prefixes = Util_js_1.default.intoArray(allowMention);
        if (allowMention) {
            const mentions = [`<@${this.client.user?.id}>`, `<@!${this.client.user?.id}>`];
            prefixes = [...mentions, ...prefixes];
        }
        prefixes.sort(Util_js_1.default.prefixCompare);
        return this.parseMultiplePrefixes(message, prefixes.map(p => [p, null]));
    }
    /**
     * Parses the command and its argument list using prefix overwrites.
     * @param message - Message that called the command.
     */
    async parseCommandOverwrittenPrefixes(message) {
        if (!this.prefixes.size) {
            return {};
        }
        const promises = this.prefixes.map(async (cmds, provider) => {
            const prefixes = Util_js_1.default.intoArray(await Util_js_1.default.intoCallable(provider)(message));
            return prefixes.map(p => [p, cmds]);
        });
        const pairs = (await Promise.all(promises)).flat(1);
        pairs.sort(([a], [b]) => Util_js_1.default.prefixCompare(a, b));
        return this.parseMultiplePrefixes(message, pairs);
    }
    /**
     * Runs parseWithPrefix on multiple prefixes and returns the best parse.
     * @param message - Message to parse.
     * @param pairs - Pairs of prefix to associated commands. That is, `[string, Set<string> | null][]`.
     */
    parseMultiplePrefixes(message, pairs) {
        const parses = pairs.map(([prefix, cmds]) => this.parseWithPrefix(message, prefix, cmds));
        const result = parses.find(parsed => parsed.command);
        if (result) {
            return result;
        }
        const guess = parses.find(parsed => parsed.prefix != null);
        if (guess) {
            return guess;
        }
        return {};
    }
    /**
     * Tries to parse a message with the given prefix and associated commands.
     * Associated commands refer to when a prefix is used in prefix overrides.
     * @param message - Message to parse.
     * @param prefix - Prefix to use.
     * @param associatedCommands - Associated commands.
     */
    parseWithPrefix(message, prefix, associatedCommands = null) {
        const lowerContent = message.content.toLowerCase();
        if (!lowerContent.startsWith(prefix.toLowerCase())) {
            return {};
        }
        const endOfPrefix = lowerContent.indexOf(prefix.toLowerCase()) + prefix.length;
        const startOfArgs = message.content.slice(endOfPrefix).search(/\S/) + prefix.length;
        const alias = message.content.slice(startOfArgs).split(/\s{1,}|\n{1,}/)[0];
        const command = this.findCommand(alias);
        const content = message.content.slice(startOfArgs + alias.length + 1).trim();
        const afterPrefix = message.content.slice(prefix.length).trim();
        if (!command) {
            return { prefix, alias, content, afterPrefix };
        }
        if (associatedCommands == null) {
            if (command.prefix != null) {
                return { prefix, alias, content, afterPrefix };
            }
        }
        else if (!associatedCommands.has(command.id)) {
            return { prefix, alias, content, afterPrefix };
        }
        return { command, prefix, alias, content, afterPrefix };
    }
    /**
     * Handles errors from the handling.
     * @param err - The error.
     * @param message - Message that called the command.
     * @param command - Command that errored.
     */
    emitError(err, message, command) {
        if (this.listenerCount(Constants_js_1.CommandHandlerEvents.ERROR)) {
            this.emit(Constants_js_1.CommandHandlerEvents.ERROR, err, message, command);
            return;
        }
        throw err;
    }
    /**
     * Sweep command util instances from cache and returns amount sweeped.
     * @param lifetime - Messages older than this will have their command util instance sweeped. This is in milliseconds and defaults to the `commandUtilLifetime` option.
     */
    sweepCommandUtil(lifetime = this.commandUtilLifetime) {
        let count = 0;
        for (const commandUtil of this.commandUtils.values()) {
            const now = Date.now();
            const message = commandUtil.message;
            if (now - (message.editedTimestamp || message.createdTimestamp) > lifetime) {
                count++;
                this.commandUtils.delete(message.id);
            }
        }
        return count;
    }
    /**
     * Adds an ongoing prompt in order to prevent command usage in the channel.
     * @param channel - Channel to add to.
     * @param user - User to add.
     */
    addPrompt(channel, user) {
        let users = this.prompts.get(channel.id);
        if (!users)
            this.prompts.set(channel.id, new Set());
        users = this.prompts.get(channel.id);
        users?.add(user.id);
    }
    /**
     * Removes an ongoing prompt.
     * @param channel - Channel to remove from.
     * @param user - User to remove.
     */
    removePrompt(channel, user) {
        const users = this.prompts.get(channel.id);
        if (!users)
            return;
        users.delete(user.id);
        if (!users.size)
            this.prompts.delete(user.id);
    }
    /**
     * Checks if there is an ongoing prompt.
     * @param channel - Channel to check.
     * @param user - User to check.
     */
    hasPrompt(channel, user) {
        const users = this.prompts.get(channel.id);
        if (!users)
            return false;
        return users.has(user.id);
    }
    /**
     * Finds a command by alias.
     * @param name - Alias to find with.
     */
    findCommand(name) {
        return this.modules.get(this.aliases.get(name.toLowerCase()));
    }
    /**
     * Set the inhibitor handler to use.
     * @param inhibitorHandler - The inhibitor handler.
     */
    useInhibitorHandler(inhibitorHandler) {
        this.inhibitorHandler = inhibitorHandler;
        this.resolver.inhibitorHandler = inhibitorHandler;
        return this;
    }
    /**
     * Set the listener handler to use.
     * @param listenerHandler - The listener handler.
     */
    useListenerHandler(listenerHandler) {
        this.resolver.listenerHandler = listenerHandler;
        return this;
    }
    /**
     * Set the task handler to use.
     * @param taskHandler - The task handler.
     */
    useTaskHandler(taskHandler) {
        this.resolver.taskHandler = taskHandler;
        return this;
    }
    /**
     * Set the context menu command handler to use.
     * @param contextMenuCommandHandler - The context menu command handler.
     */
    useContextMenuCommandHandler(contextMenuCommandHandler) {
        this.resolver.contextMenuCommandHandler = contextMenuCommandHandler;
        return this;
    }
}
exports.default = CommandHandler;
class RegisterInteractionCommandError extends Error {
    constructor(original, type, data, guild = null) {
        super("Failed to register interaction commands.");
        this.original = original;
        this.type = type;
        this.data = data;
        this.guild = guild;
    }
}
exports.RegisterInteractionCommandError = RegisterInteractionCommandError;
const slashResolvable = ["Boolean", "Channel", "String", "Integer", "Number", "User", "Member", "Role", "Mentionable"];
// todo: remove this once discord-api-types updates
/**
 * Used for reverse mapping since discord exports its enums as const enums.
 * @internal
 */
var AkairoApplicationCommandOptionType;
(function (AkairoApplicationCommandOptionType) {
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Subcommand"] = 1] = "Subcommand";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["SubcommandGroup"] = 2] = "SubcommandGroup";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["String"] = 3] = "String";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Integer"] = 4] = "Integer";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Boolean"] = 5] = "Boolean";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["User"] = 6] = "User";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Channel"] = 7] = "Channel";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Role"] = 8] = "Role";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Mentionable"] = 9] = "Mentionable";
    AkairoApplicationCommandOptionType[AkairoApplicationCommandOptionType["Number"] = 10] = "Number";
})(AkairoApplicationCommandOptionType || (AkairoApplicationCommandOptionType = {}));
/**
 * @typedef {CommandInteractionOptionResolver} VSCodePleaseStopRemovingMyImports
 * @internal
 */
//# sourceMappingURL=CommandHandler.js.map