"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AkairoError_js_1 = __importDefault(require("../../util/AkairoError.js"));
const Util_js_1 = __importStar(require("../../util/Util.js"));
const AkairoModule_js_1 = __importDefault(require("../AkairoModule.js"));
const Argument_js_1 = __importDefault(require("./arguments/Argument.js"));
const ArgumentRunner_js_1 = __importDefault(require("./arguments/ArgumentRunner.js"));
const ContentParser_js_1 = __importDefault(require("./ContentParser.js"));
/**
 * Represents a command.
 */
class Command extends AkairoModule_js_1.default {
    /**
     * @param id - Command ID.
     * @param options - Options for the command.
     */
    // eslint-disable-next-line complexity
    constructor(id, options) {
        super(id, { category: options?.category });
        const { aliases = [], args = this._args || this.args || [], argumentDefaults = {}, before = this.before || (() => undefined), channel = null, clientPermissions = this.clientPermissions, condition = this.condition || (() => false), cooldown = null, description = "", editable = true, flags = [], ignoreCooldown, ignorePermissions, lock, onlyNsfw = false, optionFlags = [], ownerOnly = false, prefix = this.prefix, quoted = true, ratelimit = 1, regex = this.regex, separator, slash = false, slashDefaultPermission, slashEphemeral = false, slashGuilds = [], slashOnly = false, slashOptions, slashPermissions, superUserOnly = false, typing = false, userPermissions = this.userPermissions } = options ?? {};
        if (!Util_js_1.default.isArrayOf(aliases, "string"))
            throw new TypeError("options.aliases must be an array of strings.");
        if (typeof args !== "function" && !Util_js_1.default.isArrayOf(args, "object"))
            throw new TypeError("options.args must be an array of argument objects or a function.");
        if (typeof argumentDefaults !== "object")
            throw new TypeError("options.argumentDefaults must be an object.");
        if (typeof before !== "function")
            throw new TypeError("options.before must be a function.");
        if (!["guild", "dm", null].includes(channel))
            throw new TypeError('options.channel must be either "guild" or "dm" or null.');
        if (typeof condition !== "function")
            throw new TypeError("options.condition must be a function.");
        if (typeof cooldown !== "number" && cooldown !== null)
            throw new TypeError("options.cooldown must be a number or null.");
        if (typeof editable !== "boolean")
            throw new TypeError("options.editable must be a boolean.");
        if (!Util_js_1.default.isArrayOf(flags, "string"))
            throw new TypeError("options.flags must be an array of strings.");
        if (ignoreCooldown !== undefined && !(0, Util_js_1.isStringArrayStringOrFunc)(ignoreCooldown))
            throw new TypeError("options.ignoreCooldown must be a string, function, or array of strings.");
        if (ignorePermissions !== undefined && !(0, Util_js_1.isStringArrayStringOrFunc)(ignorePermissions))
            throw new TypeError("options.ignorePermissions must be a string, function, or array of strings.");
        if (lock !== undefined && typeof lock !== "function" && !["channel", "guild", "user"].includes(lock))
            throw new TypeError("options.lock must be a function or a string with a value of 'channel', 'guild', or 'user'.");
        if (typeof onlyNsfw !== "boolean")
            throw new TypeError("options.onlyNsfw must be a boolean.");
        if (!Util_js_1.default.isArrayOf(optionFlags, "string"))
            throw new TypeError("options.optionFlags must be an array of strings.");
        if (typeof ownerOnly !== "boolean")
            throw new TypeError("options.ownerOnly must be a boolean.");
        if (prefix !== undefined && !(0, Util_js_1.isStringArrayStringOrFunc)(prefix))
            throw new TypeError("options.prefix must be a string, function, or array of strings.");
        if (typeof quoted !== "boolean")
            throw new TypeError("options.quoted must be a boolean.");
        if (typeof ratelimit !== "number")
            throw new TypeError("options.ratelimit must be a number.");
        if (regex !== undefined && typeof regex !== "function" && !(regex instanceof RegExp))
            throw new TypeError("options.regex must be a function or a RegExp.");
        if (separator !== undefined && typeof separator !== "string")
            throw new TypeError("options.separator must be a string.");
        if (typeof slash !== "boolean")
            throw new TypeError("options.slash must be a boolean.");
        if (slashDefaultPermission && typeof slashDefaultPermission !== "boolean")
            throw new TypeError("options.slashDefaultPermission must be a boolean.");
        if (typeof slashEphemeral !== "boolean")
            throw new TypeError("options.slashEphemeral must be a boolean.");
        if (!Util_js_1.default.isArrayOf(slashGuilds, "string"))
            throw new TypeError("options.slashGuilds must be an array of strings.");
        if (typeof slashOnly !== "boolean")
            throw new TypeError("options.slashOnly must be a boolean.");
        if (slashOptions !== undefined && !Util_js_1.default.isArrayOf(slashOptions, "object"))
            throw new TypeError("options.slashOptions must be an array of objects.");
        if (slashPermissions !== undefined && typeof slashPermissions !== "function" && !Util_js_1.default.isArrayOf(slashPermissions, "object"))
            throw new TypeError("options.slashPermissions must be an array of objects or a function.");
        if (typeof superUserOnly !== "boolean")
            throw new TypeError("options.superUserOnly must be a boolean.");
        if (typeof typing !== "boolean")
            throw new TypeError("options.typing must be a boolean.");
        this.aliases = aliases;
        const { flagWords, optionFlagWords } = Array.isArray(args)
            ? ContentParser_js_1.default.getFlags(args)
            : { flagWords: flags, optionFlagWords: optionFlags };
        this.contentParser = new ContentParser_js_1.default({
            flagWords,
            optionFlagWords,
            quoted,
            separator
        });
        this.argumentRunner = new ArgumentRunner_js_1.default(this);
        this.argumentGenerator = Array.isArray(args)
            ? ArgumentRunner_js_1.default.fromArguments(args.map(arg => [arg.id, new Argument_js_1.default(this, arg)]))
            : args.bind(this);
        this.argumentDefaults = argumentDefaults;
        this.before = before.bind(this);
        this.channel = channel;
        this.clientPermissions = typeof clientPermissions === "function" ? clientPermissions.bind(this) : clientPermissions;
        this.condition = condition.bind(this);
        this.cooldown = cooldown;
        this.description = Array.isArray(description) ? description.join("\n") : description;
        this.editable = Boolean(editable);
        this.lock = lock;
        this.onlyNsfw = Boolean(onlyNsfw);
        this.ownerOnly = Boolean(ownerOnly);
        this.prefix = typeof prefix === "function" ? prefix.bind(this) : prefix;
        this.ratelimit = ratelimit;
        this.regex = typeof regex === "function" ? regex.bind(this) : regex;
        this.superUserOnly = Boolean(superUserOnly);
        this.typing = Boolean(typing);
        this.userPermissions = typeof userPermissions === "function" ? userPermissions.bind(this) : userPermissions;
        if (typeof lock === "string") {
            this.lock = {
                guild: (message) => message.guild && message.guild.id,
                channel: (message) => message.channel.id,
                user: (message) => message.author.id
            }[lock];
        }
        if (this.lock)
            this.locker = new Set();
        this.ignoreCooldown = typeof ignoreCooldown === "function" ? ignoreCooldown.bind(this) : ignoreCooldown;
        this.ignorePermissions = typeof ignorePermissions === "function" ? ignorePermissions.bind(this) : ignorePermissions;
        this.slash = slash;
        this.slashDefaultPermission = slashDefaultPermission;
        this.slashEphemeral = slashEphemeral;
        this.slashGuilds = slashGuilds;
        this.slashOnly = slashOnly;
        this.slashOptions = slashOptions;
        this.slashPermissions = typeof slashPermissions === "function" ? slashPermissions.bind(this) : slashPermissions;
    }
    /**
     * Generator for arguments.
     * When yielding argument options, that argument is ran and the result of the processing is given.
     * The last value when the generator is done is the resulting `args` for the command's `exec`.
     * @param message - Message that triggered the command.
     * @param parsed - Parsed content.
     * @param state - Argument processing state.
     */
    // @ts-expect-error
    *args(message, parsed, state) { }
    /**
     * Runs before argument parsing and execution.
     * @param message - Message being handled.
     */
    before(message) { }
    /**
     * Checks if the command should be ran by using an arbitrary condition.
     * @param message - Message being handled.
     */
    condition(message) {
        return false;
    }
    exec(message, args) {
        throw new AkairoError_js_1.default("NOT_IMPLEMENTED", this.constructor.name, "exec");
    }
    /**
     * Execute the slash command
     * @param message - Message for slash command
     * @param args - Slash command options
     */
    execSlash(message, ...args) {
        throw new AkairoError_js_1.default("NOT_IMPLEMENTED", this.constructor.name, "execSlash");
    }
    /**
     * Respond to autocomplete interactions for this command.
     * @param interaction The autocomplete interaction
     */
    autocomplete(interaction) { }
    /**
     * Parses content using the command's arguments.
     * @param message - Message to use.
     * @param content - String to parse.
     */
    parse(message, content) {
        const parsed = this.contentParser.parse(content);
        return this.argumentRunner.run(message, parsed, this.argumentGenerator);
    }
}
exports.default = Command;
/**
 * @typedef {ApplicationCommandOptionType} VSCodePleaseStopRemovingMyImports
 * @internal
 */
//# sourceMappingURL=Command.js.map